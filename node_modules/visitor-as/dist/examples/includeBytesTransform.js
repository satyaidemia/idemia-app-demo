import { TransformVisitor, SimpleParser } from "../index.js";
import { IdentifierExpression, } from "assemblyscript/dist/assemblyscript.js";
import { not, isStdlib } from "../utils.js";
import * as path from "path";
import * as fs from "fs";
class IncludeBytesTransform extends TransformVisitor {
    visitCallExpression(node) {
        if (node.expression instanceof IdentifierExpression) {
            if (node.expression.text == "includeBytes") {
                if (!node.args[0].isLiteralKind(2 /* LiteralKind.String */))
                    throw "[Error] includeBytes requires a constant literal filename";
                let arg0 = node.args[0];
                let filename = path.join(path.dirname(node.range.source.normalizedPath), arg0.value);
                var data;
                try {
                    data = fs.readFileSync(filename);
                }
                catch (e) {
                    throw `[Error] includeBytes '${filename}', ${e}`;
                }
                let asJSONString = JSON.stringify(data); // use stringify to convert bytes to text
                let arrayStart = asJSONString.indexOf("["); //find the u8 array inside the JSON string
                let arrayEnd = asJSONString.lastIndexOf("]");
                let newCode = "StaticArray.fromArray<u8>(" +
                    asJSONString.substring(arrayStart, arrayEnd + 1) +
                    ")";
                let res = SimpleParser.parseExpression(newCode); //parse StaticArray.fromArray expression
                res.range = node.range; //same range
                return res; //replace node
            }
        }
        return super.visitCallExpression(node);
    }
    afterParse(_) {
        let sources = _.sources.filter(not(isStdlib));
        this.visit(sources);
    }
}
export default IncludeBytesTransform;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5jbHVkZUJ5dGVzVHJhbnNmb3JtLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2V4YW1wbGVzL2luY2x1ZGVCeXRlc1RyYW5zZm9ybS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsWUFBWSxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQzdELE9BQU8sRUFJTCxvQkFBb0IsR0FHckIsTUFBTSx1Q0FBdUMsQ0FBQztBQUMvQyxPQUFPLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUM1QyxPQUFPLEtBQUssSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUM3QixPQUFPLEtBQUssRUFBRSxNQUFNLElBQUksQ0FBQztBQUV6QixNQUFNLHFCQUFzQixTQUFRLGdCQUFnQjtJQUNsRCxtQkFBbUIsQ0FBQyxJQUFvQjtRQUN0QyxJQUFJLElBQUksQ0FBQyxVQUFVLFlBQVksb0JBQW9CLEVBQUU7WUFDbkQsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksSUFBSSxjQUFjLEVBQUU7Z0JBQzFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsNEJBQW9CO29CQUNqRCxNQUFNLDJEQUEyRCxDQUFDO2dCQUNwRSxJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBNEIsQ0FBQztnQkFDbkQsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FDdEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsRUFDOUMsSUFBSSxDQUFDLEtBQUssQ0FDWCxDQUFDO2dCQUNGLElBQUksSUFBSSxDQUFDO2dCQUNULElBQUk7b0JBQ0YsSUFBSSxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7aUJBQ2xDO2dCQUFDLE9BQU8sQ0FBQyxFQUFFO29CQUNWLE1BQU0seUJBQXlCLFFBQVEsTUFBTSxDQUFDLEVBQUUsQ0FBQztpQkFDbEQ7Z0JBQ0QsSUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLHlDQUF5QztnQkFDbEYsSUFBSSxVQUFVLEdBQUcsWUFBWSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLDBDQUEwQztnQkFDdEYsSUFBSSxRQUFRLEdBQUcsWUFBWSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDN0MsSUFBSSxPQUFPLEdBQ1QsNEJBQTRCO29CQUM1QixZQUFZLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRSxRQUFRLEdBQUcsQ0FBQyxDQUFDO29CQUNoRCxHQUFHLENBQUM7Z0JBQ04sSUFBSSxHQUFHLEdBQUcsWUFBWSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLHdDQUF3QztnQkFDekYsR0FBRyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsWUFBWTtnQkFDcEMsT0FBTyxHQUFHLENBQUMsQ0FBQyxjQUFjO2FBQzNCO1NBQ0Y7UUFDRCxPQUFPLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBRUQsVUFBVSxDQUFDLENBQVM7UUFDbEIsSUFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDOUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUN0QixDQUFDO0NBQ0Y7QUFFRCxlQUFlLHFCQUFxQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVHJhbnNmb3JtVmlzaXRvciwgU2ltcGxlUGFyc2VyIH0gZnJvbSBcIi4uL2luZGV4LmpzXCI7XHJcbmltcG9ydCB7XHJcbiAgRXhwcmVzc2lvbixcclxuICBQYXJzZXIsXHJcbiAgQ2FsbEV4cHJlc3Npb24sXHJcbiAgSWRlbnRpZmllckV4cHJlc3Npb24sXHJcbiAgTGl0ZXJhbEtpbmQsXHJcbiAgU3RyaW5nTGl0ZXJhbEV4cHJlc3Npb24sXHJcbn0gZnJvbSBcImFzc2VtYmx5c2NyaXB0L2Rpc3QvYXNzZW1ibHlzY3JpcHQuanNcIjtcclxuaW1wb3J0IHsgbm90LCBpc1N0ZGxpYiB9IGZyb20gXCIuLi91dGlscy5qc1wiO1xyXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJwYXRoXCI7XHJcbmltcG9ydCAqIGFzIGZzIGZyb20gXCJmc1wiO1xyXG5cclxuY2xhc3MgSW5jbHVkZUJ5dGVzVHJhbnNmb3JtIGV4dGVuZHMgVHJhbnNmb3JtVmlzaXRvciB7XHJcbiAgdmlzaXRDYWxsRXhwcmVzc2lvbihub2RlOiBDYWxsRXhwcmVzc2lvbik6IEV4cHJlc3Npb24ge1xyXG4gICAgaWYgKG5vZGUuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIElkZW50aWZpZXJFeHByZXNzaW9uKSB7XHJcbiAgICAgIGlmIChub2RlLmV4cHJlc3Npb24udGV4dCA9PSBcImluY2x1ZGVCeXRlc1wiKSB7XHJcbiAgICAgICAgaWYgKCFub2RlLmFyZ3NbMF0uaXNMaXRlcmFsS2luZChMaXRlcmFsS2luZC5TdHJpbmcpKVxyXG4gICAgICAgICAgdGhyb3cgXCJbRXJyb3JdIGluY2x1ZGVCeXRlcyByZXF1aXJlcyBhIGNvbnN0YW50IGxpdGVyYWwgZmlsZW5hbWVcIjtcclxuICAgICAgICBsZXQgYXJnMCA9IG5vZGUuYXJnc1swXSBhcyBTdHJpbmdMaXRlcmFsRXhwcmVzc2lvbjtcclxuICAgICAgICBsZXQgZmlsZW5hbWUgPSBwYXRoLmpvaW4oXHJcbiAgICAgICAgICBwYXRoLmRpcm5hbWUobm9kZS5yYW5nZS5zb3VyY2Uubm9ybWFsaXplZFBhdGgpLFxyXG4gICAgICAgICAgYXJnMC52YWx1ZVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdmFyIGRhdGE7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGRhdGEgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZW5hbWUpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIHRocm93IGBbRXJyb3JdIGluY2x1ZGVCeXRlcyAnJHtmaWxlbmFtZX0nLCAke2V9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGFzSlNPTlN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGRhdGEpOyAvLyB1c2Ugc3RyaW5naWZ5IHRvIGNvbnZlcnQgYnl0ZXMgdG8gdGV4dFxyXG4gICAgICAgIGxldCBhcnJheVN0YXJ0ID0gYXNKU09OU3RyaW5nLmluZGV4T2YoXCJbXCIpOyAvL2ZpbmQgdGhlIHU4IGFycmF5IGluc2lkZSB0aGUgSlNPTiBzdHJpbmdcclxuICAgICAgICBsZXQgYXJyYXlFbmQgPSBhc0pTT05TdHJpbmcubGFzdEluZGV4T2YoXCJdXCIpO1xyXG4gICAgICAgIGxldCBuZXdDb2RlID1cclxuICAgICAgICAgIFwiU3RhdGljQXJyYXkuZnJvbUFycmF5PHU4PihcIiArXHJcbiAgICAgICAgICBhc0pTT05TdHJpbmcuc3Vic3RyaW5nKGFycmF5U3RhcnQsIGFycmF5RW5kICsgMSkgK1xyXG4gICAgICAgICAgXCIpXCI7XHJcbiAgICAgICAgbGV0IHJlcyA9IFNpbXBsZVBhcnNlci5wYXJzZUV4cHJlc3Npb24obmV3Q29kZSk7IC8vcGFyc2UgU3RhdGljQXJyYXkuZnJvbUFycmF5IGV4cHJlc3Npb25cclxuICAgICAgICByZXMucmFuZ2UgPSBub2RlLnJhbmdlOyAvL3NhbWUgcmFuZ2VcclxuICAgICAgICByZXR1cm4gcmVzOyAvL3JlcGxhY2Ugbm9kZVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3VwZXIudmlzaXRDYWxsRXhwcmVzc2lvbihub2RlKTtcclxuICB9XHJcblxyXG4gIGFmdGVyUGFyc2UoXzogUGFyc2VyKTogdm9pZCB7XHJcbiAgICBsZXQgc291cmNlcyA9IF8uc291cmNlcy5maWx0ZXIobm90KGlzU3RkbGliKSk7XHJcbiAgICB0aGlzLnZpc2l0KHNvdXJjZXMpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgSW5jbHVkZUJ5dGVzVHJhbnNmb3JtO1xyXG4iXX0=