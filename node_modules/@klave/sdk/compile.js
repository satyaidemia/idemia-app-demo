"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// libs/sdk/src/compile.ts
var fs = __toESM(require("fs-extra"));
var path = __toESM(require("node:path"));
var import_chalk = __toESM(require("chalk"));
var import_path_complete_extname = require("path-complete-extname");
var import_compiler = require("@klave/compiler");

// libs/constants/src/utils/repoConfigChecker.ts
var import_zod = require("zod");
var repoConfigSchemaV0 = import_zod.z.object({
  version: import_zod.z.string().or(import_zod.z.number()).optional(),
  branch: import_zod.z.string().optional(),
  targetCluster: import_zod.z.string().optional(),
  applications: import_zod.z.array(import_zod.z.object(
    {
      name: import_zod.z.string(),
      description: import_zod.z.string().optional(),
      version: import_zod.z.string().optional(),
      index: import_zod.z.string().optional(),
      rootDir: import_zod.z.string()
    }
  )).optional()
});
var repoConfigSchemaV1 = import_zod.z.object({
  schema: import_zod.z.string().or(import_zod.z.number()).optional(),
  branches: import_zod.z.array(import_zod.z.string()).optional(),
  targetCluster: import_zod.z.string().optional(),
  applications: import_zod.z.array(import_zod.z.object(
    {
      slug: import_zod.z.string(),
      description: import_zod.z.string().optional(),
      version: import_zod.z.string().optional(),
      index: import_zod.z.string().optional(),
      rootDir: import_zod.z.string()
    }
  )).optional()
});
var getFinalParseConfig = (config) => {
  const objectParse = typeof config === "string" ? JSON.parse(config ?? "{}") : config ?? {};
  let originalParse = repoConfigSchemaV1.safeParse(objectParse);
  if (!originalParse.success) {
    const newParse = repoConfigSchemaV0.safeParse(objectParse);
    originalParse = {
      ...newParse,
      data: newParse.success ? {
        ...originalParse?.data || {},
        ...newParse.data,
        branches: newParse.data.branch ? [newParse.data.branch] : void 0,
        applications: newParse.data.applications?.map((app) => {
          const newApp = {
            ...app,
            slug: app.name.replaceAll(/\W/g, "-").toLocaleLowerCase()
          };
          return newApp;
        })
      } : void 0,
      chainError: originalParse.error
    };
  } else {
    originalParse.data.applications = originalParse.data.applications?.map((app) => {
      app.slug = app.slug.replaceAll(/\W/g, "-").toLocaleLowerCase();
      return app;
    });
  }
  return originalParse;
};

// libs/sdk/src/compile.ts
var CWD = process.env["INIT_CWD"] || process.cwd();
var compile = () => {
  try {
    const configContent = fs.readFileSync(path.join(CWD, "klave.json")).toString();
    const parsingOutput = getFinalParseConfig(configContent);
    if (parsingOutput.success)
      Promise.allSettled((parsingOutput.data.applications ?? []).map(async (app, index) => new Promise((resolve2, reject) => {
        const appPathRoot = path.join(CWD, app.rootDir ?? ".");
        let appPath = path.join(appPathRoot, app.index ?? "");
        if (!fs.existsSync(appPath) || !fs.statSync(appPath).isFile())
          appPath = path.join(appPathRoot, "index.ssc");
        if (!fs.existsSync(appPath) || !fs.statSync(appPath).isFile())
          appPath = path.join(appPathRoot, "index.ssc.ts");
        if (!fs.existsSync(appPath) || !fs.statSync(appPath).isFile())
          appPath = path.join(appPathRoot, "index.ts");
        if (!fs.existsSync(appPath) || !fs.statSync(appPath).isFile())
          console.error(`Could not read entry point for application ${import_chalk.default.green(app.slug)}`);
        console.error(`Compiling ${import_chalk.default.green(app.slug)} from ${path.join(".", path.relative(CWD, appPath))}...`);
        fs.mkdirSync(path.join(CWD, ".klave"), { recursive: true });
        (0, import_compiler.createCompiler)().then((compiler) => {
          compiler.on("message", (message) => {
            if (message.type === "start") {
              console.log(`Using Klave compiler v${compiler.version}
AssemblyScript v${compiler.ascVersion ?? message.version}`);
            }
            if (message.type === "read") {
              if (process.env["DEBUG"] === "true")
                console.debug("file_read_try:" + path.resolve(appPathRoot, message.filename));
              fs.readFile(path.resolve(appPathRoot, message.filename)).then((contents) => {
                compiler.postMessage({
                  type: "read",
                  id: message.id,
                  contents: contents.toString()
                });
              }).catch(() => {
                compiler.postMessage({
                  type: "read",
                  id: message.id,
                  contents: null
                });
              });
            } else if (message.type === "write") {
              const ext = (0, import_path_complete_extname.posix)(message.filename);
              if (ext.endsWith(".js"))
                return;
              if (message.contents)
                fs.writeFileSync(`${path.join(CWD, ".klave", `${index.toString()}-${app.slug.toLocaleLowerCase().replace(/\s/g, "-")}`)}${ext}`, message.contents);
            } else if (message.type === "diagnostic") {
              if (process.env["DEBUG"] === "true")
                console.debug(message.diagnostics);
            } else if (message.type === "errored") {
              compiler.terminate().finally(() => {
                reject(message);
              }).catch(reject);
            } else if (message.type === "done") {
              resolve2();
            }
          });
        }).catch(reject);
      }))).then((results) => {
        const erroredList = results.filter((result) => result.status === "rejected");
        if (erroredList.length > 0) {
          erroredList.forEach((result) => console.error(import_chalk.default.red(result.reason.stderr ?? result.reason.error?.message ?? "Unknown error")));
          process.exit(1);
        } else
          process.exit(0);
      }).catch(() => {
        return;
      });
    else
      console.error(parsingOutput.error.flatten());
  } catch (e) {
    console.error(e);
  }
};
compile();
