"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    CompilerHost: function() {
        return CompilerHost;
    },
    createCompiler: function() {
        return createCompiler;
    }
});
const _nodeworker_threads = require("node:worker_threads");
const _typescript = _interop_require_default(require("typescript"));
const _uuid = require("uuid");
const _languageService = require("./languageService");
const _compilerModule = require("./compilerModule");
const _packagejson = _interop_require_default(require("../package.json"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const deferredMarker = '__klave_deferred__';
let CompilerHost = class CompilerHost {
    constructor(worker){
        this.worker = worker;
        this.id = (0, _uuid.v4)();
        this.version = _packagejson.default.version;
        this.ascVersion = 'unknown';
        this.entryFile = -1;
    }
    on(event, listener) {
        if (event === 'message') {
            this.worker.on('message', (message)=>{
                if (message.type === 'start') {
                    this.ascVersion = message.version;
                }
                if (message.type === 'write') {
                    if (message.filename === 'out.d.ts' && message.contents) {
                        let filteredDTS = '';
                        const sourceFile = _typescript.default.createSourceFile(`${this.id}.d.ts`, message.contents.toLocaleString(), _typescript.default.ScriptTarget.Latest, true);
                        const seenFunctions = [];
                        _typescript.default.forEachChild(sourceFile, (node)=>{
                            if (_typescript.default.isFunctionDeclaration(node)) {
                                if (node.name && ![
                                    'register_routes',
                                    '__new',
                                    '__pin',
                                    '__unpin',
                                    '__collect'
                                ].includes(node.name.text) && !seenFunctions.includes(node.name.text)) {
                                    if (node.name.text.startsWith(deferredMarker)) seenFunctions.push(node.name.text.replace(deferredMarker, ''));
                                    filteredDTS += `${node.getFullText().replaceAll(deferredMarker, '').trim()}\n`;
                                }
                            }
                        });
                        message.contents = filteredDTS;
                    }
                    return listener(message);
                }
                if (message.type === 'read') {
                    if (message.filename === '..ts' || message.filename === 'index.ts' || message.filename === './index.ts' || message.filename === '.\\index.ts') this.entryFile = message.id;
                }
                listener(message);
            });
        } else this.worker.on(event, listener);
        return this;
    }
    postMessage(value, transferList) {
        if (value.type === 'read') {
            if (value.id === this.entryFile && value.contents) {
                let normalizedEntryFile = `
                import { JSON as ${deferredMarker}JSON, Utils as ${deferredMarker}Utils } from '@klave/sdk';
                `;
                const sourceFile = _typescript.default.createSourceFile(`${this.id}.d.ts`, value.contents, _typescript.default.ScriptTarget.Latest, true);
                let shouldAddRouting = true;
                const exportedFunctions = {
                    transactions: [],
                    queries: []
                };
                _typescript.default.forEachChild(sourceFile, (node)=>{
                    if (_typescript.default.isFunctionDeclaration(node)) {
                        if (node.name?.text === 'register_routes') {
                            shouldAddRouting = false;
                            normalizedEntryFile += `${node.getFullText().trim()}\n`;
                        } else if (node.flags && node.modifiers?.some((m)=>m.kind === _typescript.default.SyntaxKind.ExportKeyword)) {
                            if (node.name?.text) {
                                const tags = _typescript.default.getAllJSDocTagsOfKind(node, _typescript.default.SyntaxKind.JSDocTag);
                                const tagNames = new Set(tags.map((tag)=>tag.tagName.text));
                                if (tagNames.has('transaction')) exportedFunctions.transactions.push(node.name.text);
                                else if (tagNames.has('query')) exportedFunctions.queries.push(node.name.text);
                                const inputParam = node.parameters[0];
                                if (inputParam) {
                                    const inputParamName = inputParam.name.getText();
                                    const inputParamType = inputParam.type?.getText();
                                    if (inputParamType && inputParamType !== 'i32') {
                                        const mangledName = `${deferredMarker}${node.name.text}`;
                                        normalizedEntryFile += `${node.getFullText().replace(node.name.text, mangledName).trim()}\n`;
                                        normalizedEntryFile += `
                                        export function ${node.name.text}(${inputParamName}: i32): void {
                                            const ${inputParamName}String = ${deferredMarker}Utils.pointerToString(${inputParamName});
                                            const ${inputParamName}Object = ${deferredMarker}JSON.parse<${inputParamType}>(${inputParamName}String);
                                            return ${mangledName}(${inputParamName}Object);
                                        }`;
                                    } else {
                                        normalizedEntryFile += `${node.getFullText().trim()}\n`;
                                    }
                                } else {
                                    const mangledName = `${deferredMarker}${node.name.text}`;
                                    normalizedEntryFile += `${node.getFullText().replace(node.name.text, mangledName).trim()}\n`;
                                    normalizedEntryFile += `
                                        export function ${node.name.text}(_no_args_: i32): void {
                                            return ${mangledName}();
                                        }`;
                                }
                            } else {
                                normalizedEntryFile += `${node.getFullText().trim()}\n`;
                            }
                        }
                    } else {
                        normalizedEntryFile += `${node.getFullText().trim()}\n`;
                    }
                });
                if (shouldAddRouting) normalizedEntryFile += `
                    // @ts-ignore: decorator
                    @external("env", "add_user_query")
                    declare function runtime_add_user_query(s: ArrayBuffer): void;
                    // @ts-ignore: decorator
                    @external("env", "add_user_transaction")
                    declare function runtime_add_user_transaction(s: ArrayBuffer): void;
                    export function register_routes(): void {
                        ${exportedFunctions.queries.map((name)=>`runtime_add_user_query(String.UTF8.encode("${name}", true));`).join('\n')}
                        ${exportedFunctions.transactions.map((name)=>`runtime_add_user_transaction(String.UTF8.encode("${name}", true));`).join('\n')}
                    }
                `;
                normalizedEntryFile = (0, _languageService.formatter)(normalizedEntryFile);
                value.contents = normalizedEntryFile;
            }
        }
        this.worker.postMessage(value, transferList);
    }
    async terminate() {
        return this.worker.terminate();
    }
};
const createCompiler = async ()=>{
    const workerCodeBase = _compilerModule.compilerModuleFunction.toString();
    const workerCode = workerCodeBase.substring(workerCodeBase.indexOf('=>') + 2).replaceAll('_interop_require_wildcard(require', '(import');
    const worker = new _nodeworker_threads.Worker(workerCode, {
        eval: true,
        name: 'Klave WASM Compiler',
        env: {},
        argv: []
    });
    const compiler = new CompilerHost(worker);
    compiler.postMessage({
        type: 'compile'
    });
    return compiler;
};

//# sourceMappingURL=compilerWorker.js.map